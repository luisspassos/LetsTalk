<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script
      src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js"
      crossorigin="anonymous"
    ></script>
    <style>
      :root {
        --right-spacing: 0.05em;
        --left-spacing: 0.1em;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, Helvetica, sans-serif;
      }

      body {
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .container {
        display: flex;
        flex-direction: column;
        gap: 0.625rem;
      }

      .container button {
        height: 3.125rem;
        font-size: 1.25rem;
        font-weight: bold;
      }

      .messageInput {
        min-height: 2.5rem;
        width: 31.25rem;
        font-size: 1.25rem;
        line-height: 1.5rem;
        border: 1px solid white;
        background-color: darkgray;
        padding: 0.78125rem 0.625rem;
      }

      .invisibleCaret {
        caret-color: transparent;
      }

      .emojiWrapper {
        height: 100%;
        display: flex;
        align-items: center;
      }

      .emoji {
        height: 1em;
        width: 1em;
        margin: 0 var(--right-spacing) 0 var(--left-spacing);
        vertical-align: -0.1em;
      }

      .emojiIsFirstChild {
        margin: 0 var(--right-spacing) 0 0;
      }

      .emojiIsLastChild {
        margin: 0 0 0 var(--left-spacing);
      }

      .emojiIsFirstChildAndLast {
        margin: 0;
      }

      .selectedEmoji {
        margin: 0;
      }

      .selectedEmojiDefault {
        width: calc(1em + var(--right-spacing) + var(--left-spacing));
        padding: 0 var(--right-spacing) 0 var(--left-spacing);
      }

      .selectedEmojiIsFirstChild {
        width: calc(1em + var(--right-spacing));
        padding: 0 var(--right-spacing) 0 0;
      }

      .selectedEmojiIsLastChild {
        width: calc(1em + var(--left-spacing));
        padding: 0 0 0 var(--left-spacing);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div contenteditable id="messageInput" class="messageInput"></div>
      <button id="copyButton">Copy and paste emoji</button>
    </div>

    <script>
      const copyButton = document.getElementById('copyButton');
      const messageInput = document.querySelector('.messageInput');

      const selection = window.getSelection();

      function getFirstAndLastChildOfMessageInput() {
        const firstChildOfMessageInput = messageInput.firstChild;
        const lastChildOfMessageInput = messageInput.lastChild;

        return { firstChildOfMessageInput, lastChildOfMessageInput };
      }

      function getEmojis() {
        const emojis = messageInput.querySelectorAll('.emoji');

        return emojis;
      }

      function addSelection(range) {
        selection.removeAllRanges();
        selection.addRange(range);
      }

      function insertTextAtCursor() {
        const emojiInserted = document.createElement('img');
        emojiInserted.src =
          'https://raw.githubusercontent.com/twitter/twemoji/ad3d3d669bb3697946577247ebb15818f09c6c91/assets/svg/1f415-200d-1f9ba.svg';
        emojiInserted.alt = 'ðŸ•â€ðŸ¦º';
        emojiInserted.classList.add('emoji');

        const focusedElem = document.activeElement;
        const messageInputIsFocused = focusedElem.className === 'messageInput';

        if (!messageInputIsFocused) {
          messageInput.focus();
          messageInput.innerHTML += emojiInserted.outerHTML;

          function putCursorAtTheEnd() {
            selection.selectAllChildren(messageInput);
            selection.collapseToEnd();
          }

          putCursorAtTheEnd();

          return;
        }

        function positionCursor() {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          range.insertNode(emojiInserted);
          range.setStartAfter(emojiInserted);

          addSelection(range);
        }

        positionCursor();
      }

      function convertTextFromMessageInputToHtml(text) {
        const convertedText = twemoji.parse(text);

        const convertedTextHtml = document.createElement('span');
        convertedTextHtml.innerHTML = convertedText;

        return convertedTextHtml;
      }

      messageInput.addEventListener('dragstart', (e) => {
        e.preventDefault();
      });

      let oldMessage = '';

      messageInput.addEventListener('beforeinput', (e) => {
        oldMessage = messageInput.innerHTML;
      });

      let continueInputEvent = true;

      let currentEmojiId = 0;

      messageInput.addEventListener('input', (e) => {
        function handleEmojiClasses() {
          const emojis = getEmojis();

          const { firstChildOfMessageInput, lastChildOfMessageInput } =
            getFirstAndLastChildOfMessageInput();

          emojis.forEach((emoji) => {
            function handleClass(condition, className) {
              if (condition) {
                emoji.classList.add(className);
                return;
              }

              emoji.classList.remove(className);
            }

            handleClass(
              firstChildOfMessageInput === emoji &&
                lastChildOfMessageInput === emoji,
              'emojiIsFirstChildAndLast'
            );

            handleClass(
              firstChildOfMessageInput === emoji,
              'emojiIsFirstChild'
            );

            handleClass(lastChildOfMessageInput === emoji, 'emojiIsLastChild');
          });
        }

        handleEmojiClasses();

        const emojiRegex = /\p{Extended_Pictographic}/u;
        const thereIsEmojiInTheMessage = emojiRegex.test(
          messageInput.textContent
        );

        if (!continueInputEvent) {
          messageInput.innerHTML = oldMessage;

          handleEmojiClasses();

          const range = document.createRange();

          const currentEmoji = document.querySelector(
            `#messageInputEmoji${currentEmojiId}`
          );

          range.setStartAfter(currentEmoji);
          addSelection(range);

          return;
        }

        if (!thereIsEmojiInTheMessage) return;

        const message = messageInput.innerHTML;

        const newMessageHtml = document.createElement('span');

        newMessageHtml.innerHTML = message;

        twemoji.parse(newMessageHtml);

        const newMessage = newMessageHtml.innerHTML;

        messageInput.innerHTML = newMessage;

        const newEmojis = getEmojis();

        currentEmojiId++;

        newEmojis.forEach((emoji) => {
          if (!emoji.id) {
            emoji.id = 'messageInputEmoji' + currentEmojiId;
          }
        });

        continueInputEvent = false;

        // to fix the duplicate emojis bug
        setTimeout(() => {
          continueInputEvent = true;
        }, 0);
      });

      messageInput.addEventListener('drop', (e) => {
        e.preventDefault();

        const dataTransfer = e.dataTransfer;
        const draggedText = dataTransfer.getData('text');
        const convertedDraggedTextHtml =
          convertTextFromMessageInputToHtml(draggedText);

        function handleSelection() {
          let range;

          if (document.caretRangeFromPoint) {
            range = document.caretRangeFromPoint(e.clientX, e.clientY);
          } else {
            const pos = [e.rangeParent, e.rangeOffset];
            range = document.createRange();
            range.setStart(...pos);
            range.setEnd(...pos);
          }

          range.insertNode(convertedDraggedTextHtml);
        }

        handleSelection();
      });

      messageInput.addEventListener('paste', (e) => {
        e.preventDefault();

        const paste = (e.clipboardData || window.clipboardData).getData('text');

        const convertedPasteHtml = convertTextFromMessageInputToHtml(paste);

        if (!selection.rangeCount) return;

        selection.deleteFromDocument();
        selection.getRangeAt(0).insertNode(convertedPasteHtml);
        selection.collapseToEnd();
      });

      copyButton.addEventListener('mousedown', (e) => {
        e.preventDefault();
      });

      copyButton.addEventListener('click', insertTextAtCursor);

      function thereIsNoSelectionInTheDocumentOrMessageInput() {
        const selection = window.getSelection();
        const haveSelection = !selection.isCollapsed;
        const isMessageInput =
          selection.anchorNode?.className === 'messageInput';

        return !haveSelection || !isMessageInput;
      }

      function handleHaveSelectedText() {
        const emojis = getEmojis();

        function handleClasses(type) {
          emojis.forEach((emoji) => {
            function classListFunc(className) {
              emoji.classList[type](className);
            }

            classListFunc('selectedEmoji');

            const { firstChildOfMessageInput, lastChildOfMessageInput } =
              getFirstAndLastChildOfMessageInput();

            if (firstChildOfMessageInput === emoji) {
              classListFunc('selectedEmojiIsFirstChild');
              return;
            }

            if (lastChildOfMessageInput === emoji) {
              classListFunc('selectedEmojiIsLastChild');
              return;
            }

            classListFunc('selectedEmojiDefault');
          });
        }

        if (thereIsNoSelectionInTheDocumentOrMessageInput()) {
          handleClasses('remove');

          return;
        }

        handleClasses('add');
      }

      document.addEventListener('selectionchange', handleHaveSelectedText);

      function handleCursorAfterDeselect() {
        if (thereIsNoSelectionInTheDocumentOrMessageInput()) return;

        messageInput.classList.add('invisibleCaret');

        setTimeout(() => {
          messageInput.classList.remove('invisibleCaret');
        }, 1);
      }

      messageInput.addEventListener('mouseup', handleCursorAfterDeselect);
    </script>
  </body>
</html>
