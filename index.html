<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script
      src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js"
      crossorigin="anonymous"
    ></script>
    <style>
      :root {
        --right-spacing: 0.08em;
        --left-spacing: 0.18em;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, Helvetica, sans-serif;
      }

      body {
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .container {
        display: flex;
        flex-direction: column;
        gap: 0.625rem;
      }

      .container button {
        height: 3.125rem;
        font-size: 1.25rem;
        font-weight: bold;
      }

      .messageInput {
        min-height: 2.5rem;
        width: 31.25rem;
        font-size: 1.25rem;
        line-height: 1.5rem;
        border: 1px solid white;
        background-color: darkgray;
        padding: 0.78125rem 0.625rem;
      }

      .messageInput[placeholder]:empty::before {
        content: attr(placeholder);
        color: white;
      }

      .invisibleCaret {
        caret-color: transparent;
      }

      .emojiWrapper {
        height: 100%;
        display: flex;
        align-items: center;
      }

      .emoji {
        height: 1em;
        width: 1em;
        margin: 0 var(--right-spacing) 0 var(--left-spacing);
        vertical-align: -0.1em;
      }

      .emojiIsFirstChild {
        margin: 0 var(--right-spacing) 0 0;
      }

      .emojiIsLastChild {
        margin: 0 0 0 var(--left-spacing);
      }

      .emojiIsFirstChildAndLast {
        margin: 0;
      }

      .selectedEmoji {
        margin: 0;
      }

      .selectedEmojiDefault {
        width: calc(1em + var(--right-spacing) + var(--left-spacing));
        padding: 0 var(--right-spacing) 0 var(--left-spacing);
      }

      .selectedEmojiIsFirstChild {
        width: calc(1em + var(--right-spacing));
        padding: 0 var(--right-spacing) 0 0;
      }

      .selectedEmojiIsLastChild {
        width: calc(1em + var(--left-spacing));
        padding: 0 0 0 var(--left-spacing);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div
        contenteditable
        placeholder="Sua mensagem..."
        class="messageInput"
      ></div>
      <button id="copyButton">Copy and paste emoji</button>
    </div>

    <script>
      const copyButton = document.getElementById('copyButton');
      const messageInput = document.querySelector('.messageInput');

      const selection = window.getSelection();

      function getCurrentEmojiInMessage() {
        const currentEmoji = document.querySelector(`#${currentEmojiId}`);

        return currentEmoji;
      }

      function getFirstAndLastChildOfMessageInput() {
        const firstChildOfMessageInput = messageInput.firstChild;
        const lastChildOfMessageInput = messageInput.lastChild;

        return { firstChildOfMessageInput, lastChildOfMessageInput };
      }

      function getEmojisInTheMessage() {
        const emojis = messageInput.querySelectorAll('.emoji');

        return emojis;
      }

      function addSelection(range) {
        selection.removeAllRanges();
        selection.addRange(range);
      }

      function insertTextAtCursor() {
        const emojiInserted = document.createElement('img');
        emojiInserted.src =
          'https://raw.githubusercontent.com/twitter/twemoji/ad3d3d669bb3697946577247ebb15818f09c6c91/assets/svg/1f415-200d-1f9ba.svg';
        emojiInserted.alt = '🐕‍🦺';
        emojiInserted.classList.add('emoji');

        const focusedElem = document.activeElement;
        const messageInputIsFocused = focusedElem.className === 'messageInput';

        if (!messageInputIsFocused) {
          messageInput.focus();
          messageInput.innerHTML += emojiInserted.outerHTML;

          function putCursorAtTheEnd() {
            selection.selectAllChildren(messageInput);
            selection.collapseToEnd();
          }

          putCursorAtTheEnd();

          return;
        }

        function positionCursor() {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          range.insertNode(emojiInserted);
          range.setStartAfter(emojiInserted);

          addSelection(range);
        }

        positionCursor();
      }

      function convertTextFromMessageInputToHtml(text) {
        const convertedText = twemoji.parse(text);

        const convertedTextHtml = document.createElement('span');
        convertedTextHtml.innerHTML = convertedText;

        return convertedTextHtml;
      }

      messageInput.addEventListener('dragstart', (e) => {
        e.preventDefault();
      });

      let oldMessage = '';

      messageInput.addEventListener('beforeinput', (e) => {
        oldMessage = messageInput.innerHTML;
      });

      let continueInputEvent = true;

      let currentEmojiId = 'messageInputEmoji0';

      messageInput.addEventListener('input', (e) => {
        function handleEmojiClasses() {
          const emojis = getEmojisInTheMessage();

          const { firstChildOfMessageInput, lastChildOfMessageInput } =
            getFirstAndLastChildOfMessageInput();

          emojis.forEach((emoji) => {
            function handleClass(condition, className) {
              if (condition) {
                emoji.classList.add(className);
                return;
              }

              emoji.classList.remove(className);
            }

            handleClass(
              firstChildOfMessageInput === emoji &&
                lastChildOfMessageInput === emoji,
              'emojiIsFirstChildAndLast'
            );

            handleClass(
              firstChildOfMessageInput === emoji,
              'emojiIsFirstChild'
            );

            handleClass(lastChildOfMessageInput === emoji, 'emojiIsLastChild');
          });
        }

        handleEmojiClasses();

        if (!continueInputEvent) {
          messageInput.innerHTML = oldMessage;

          handleEmojiClasses();

          function setSelection() {
            const currentEmoji = getCurrentEmojiInMessage();

            const range = document.createRange();

            range.setStartAfter(currentEmoji);
            addSelection(range);
          }

          setSelection();

          function addDoubleClickEventOnEmojis() {
            const emojis = getEmojisInTheMessage();

            emojis.forEach((emoji) => {
              emoji.addEventListener('dblclick', () => {
                selection.selectAllChildren(messageInput);
              });
            });
          }

          addDoubleClickEventOnEmojis();

          return;
        }

        const emojiRegex = /\p{Extended_Pictographic}/u;
        const thereIsEmojiInTheMessage = emojiRegex.test(
          messageInput.textContent
        );

        const a = messageInput.innerHTML;

        const b = document.createElement('span');

        b.innerHTML = a;

        const c =

        if (!thereIsEmojiInTheMessage) return;

        function setMessageWithEmojis() {
          const message = messageInput.innerHTML;

          const newMessageHtml = document.createElement('span');

          newMessageHtml.innerHTML = message;

          twemoji.parse(newMessageHtml);

          const newMessage = newMessageHtml.innerHTML;

          messageInput.innerHTML = newMessage;
        }

        setMessageWithEmojis();

        function setIdInNewEmoji() {
          const newEmojis = getEmojisInTheMessage();

          newEmojis.forEach((emoji) => {
            if (!emoji.id) {
              const numberRegex = /(\d+)/;
              const letterRegex = /[a-zA-Z]+/;

              const emojiIdName = currentEmojiId.match(letterRegex)[0];
              const newCurrentEmojiIdNumber =
                currentEmojiId.match(numberRegex)[0] + 1;

              const newCurrentEmojiId = emojiIdName + newCurrentEmojiIdNumber;

              currentEmojiId = newCurrentEmojiId;

              emoji.id = newCurrentEmojiId;
            }
          });
        }

        setIdInNewEmoji();

        continueInputEvent = false;

        // to fix the duplicate emojis bug
        setTimeout(() => {
          continueInputEvent = true;
        }, 0);
      });

      messageInput.addEventListener('drop', (e) => {
        e.preventDefault();

        const dataTransfer = e.dataTransfer;
        const draggedText = dataTransfer.getData('text');
        const convertedDraggedTextHtml =
          convertTextFromMessageInputToHtml(draggedText);

        function handleSelection() {
          let range;

          if (document.caretRangeFromPoint) {
            range = document.caretRangeFromPoint(e.clientX, e.clientY);
          } else {
            const pos = [e.rangeParent, e.rangeOffset];
            range = document.createRange();
            range.setStart(...pos);
            range.setEnd(...pos);
          }

          range.insertNode(convertedDraggedTextHtml);
        }

        handleSelection();
      });

      messageInput.addEventListener('paste', (e) => {
        e.preventDefault();

        const paste = (e.clipboardData || window.clipboardData).getData('text');

        const convertedPasteHtml = convertTextFromMessageInputToHtml(paste);

        if (!selection.rangeCount) return;

        selection.deleteFromDocument();
        selection.getRangeAt(0).insertNode(convertedPasteHtml);
        selection.collapseToEnd();
      });

      copyButton.addEventListener('mousedown', (e) => {
        e.preventDefault();
      });

      copyButton.addEventListener('click', insertTextAtCursor);

      function thereIsNoSelectionInTheDocumentOrMessageInput() {
        const selection = window.getSelection();
        const haveSelection = !selection.isCollapsed;
        const isMessageInput =
          selection.anchorNode?.className?.includes('messageInput');

        return !haveSelection || !isMessageInput;
      }

      function handleHaveSelectedText() {
        const emojis = getEmojisInTheMessage();

        function handleClasses(type) {
          emojis.forEach((emoji) => {
            function classListFunc(className) {
              emoji.classList[type](className);
            }

            classListFunc('selectedEmoji');

            const { firstChildOfMessageInput, lastChildOfMessageInput } =
              getFirstAndLastChildOfMessageInput();

            if (firstChildOfMessageInput === emoji) {
              classListFunc('selectedEmojiIsFirstChild');
              return;
            }

            if (lastChildOfMessageInput === emoji) {
              classListFunc('selectedEmojiIsLastChild');
              return;
            }

            classListFunc('selectedEmojiDefault');
          });
        }

        if (thereIsNoSelectionInTheDocumentOrMessageInput()) {
          handleClasses('remove');

          return;
        }

        handleClasses('add');
      }

      document.addEventListener('selectionchange', handleHaveSelectedText);

      function handleCursorAfterDeselect() {
        if (thereIsNoSelectionInTheDocumentOrMessageInput()) return;

        messageInput.classList.add('invisibleCaret');

        setTimeout(() => {
          messageInput.classList.remove('invisibleCaret');
        }, 1);
      }

      messageInput.addEventListener('mouseup', handleCursorAfterDeselect);
    </script>
  </body>
</html>
